void PostHandler::processBoundaryData(const std::string& initBody, const std::string &boundarySep, ParsRequest &data_req, std::string& location_path) {
    // Prepare boundary strings
    std::string boundary = "--" + boundarySep;
    std::string terminator = boundary + "--";
    
    // Combine leftover data from previous call with new data
    std::string body = this->leftoverData + initBody;
    
    // Clear leftover data as we're processing it now
    this->leftoverData = "";
    
    size_t pos = 0;
    
    // If we haven't started processing a file yet, look for a boundary
    if (!file.is_open()) {
        // Find first boundary
        size_t boundaryPos = body.find(boundary, pos);
        if (boundaryPos == std::string::npos) {
            // No boundary found, save all data as leftover for next call
            this->leftoverData = body;
            return;
        }
        
        // Move position after boundary + CRLF
        pos = boundaryPos + boundary.length() + 2; // +2 for \r\n
        
        // Find headers section
        size_t headersEnd = body.find("\r\n\r\n", pos);
        if (headersEnd == std::string::npos) {
            // Headers not complete, save as leftover
            this->leftoverData = body;
            return;
        }
        
        // Extract headers
        this->header = body.substr(pos, headersEnd - pos);
        
        // Extract content type and filename
        this->extension = extractContentType(header);
        std::cout << "Content type: " << this->extension << std::endl;
        
        // Extract filename from headers if available (you may need to implement this)
        std::string filename_header = extractFilename(header);
        
        // Create unique filename
        this->filename = createUniqueFile(extension, location_path);
        if (this->filename.empty()) {
            std::cerr << "Failed to create unique filename" << std::endl;
            status = 500;
            return;
        }
        std::cout << "Created file: " << this->filename << std::endl;
        
        // Open file for writing
        file.open(filename.c_str(), std::ios::binary);
        if (!file) {
            std::cerr << "Failed to open file for writing: " << filename << std::endl;
            status = 500;
            return;
        }
        
        // Move position after headers
        pos = headersEnd + 4; // +4 for \r\n\r\n
    }
    
    // Process file content
    while (pos < body.length()) {
        // Look for next boundary or terminator
        size_t nextBoundaryPos = body.find(boundary, pos);
        
        // Check if we found the terminator
        bool isTerminator = false;
        if (nextBoundaryPos != std::string::npos && 
            nextBoundaryPos + terminator.length() <= body.length() &&
            body.substr(nextBoundaryPos, terminator.length()) == terminator) {
            isTerminator = true;
        }
        
        if (nextBoundaryPos != std::string::npos) {
            // Found boundary or terminator - write data up to this point minus the CRLF
            size_t dataEnd = nextBoundaryPos - 2; // -2 to exclude the CRLF before boundary
            if (dataEnd > pos && dataEnd < body.length()) {
                file.write(body.data() + pos, dataEnd - pos);
                bodyLength += (dataEnd - pos);
            }
            
            // Close file if terminator found
            if (isTerminator) {
                file.flush();
                file.close();
                isComplete = true;
                std::cout << "File upload complete: " << filename << " (" << bodyLength << " bytes)" << std::endl;
                
                // Move position after terminator for next part (if any)
                pos = nextBoundaryPos + terminator.length() + 2; // +2 for \r\n
            } else {
                // Move position after boundary for next part
                pos = nextBoundaryPos + boundary.length() + 2; // +2 for \r\n
                
                // Close current file
                file.flush();
                file.close();
                
                // Find headers for next part
                size_t headersEnd = body.find("\r\n\r\n", pos);
                if (headersEnd == std::string::npos) {
                    // Headers not complete, save as leftover
                    this->leftoverData = body.substr(nextBoundaryPos);
                    return;
                }
                
                // Extract headers
                this->header = body.substr(pos, headersEnd - pos);
                
                // Extract content type and filename
                this->extension = extractContentType(header);
                std::cout << "Content type: " << this->extension << std::endl;
                
                // Create unique filename for next part
                this->filename = createUniqueFile(extension, location_path);
                if (this->filename.empty()) {
                    std::cerr << "Failed to create unique filename" << std::endl;
                    status = 500;
                    return;
                }
                std::cout << "Created file: " << this->filename << std::endl;
                
                // Open file for writing
                file.open(filename.c_str(), std::ios::binary);
                if (!file) {
                    std::cerr << "Failed to open file for writing: " << filename << std::endl;
                    status = 500;
                    return;
                }
                
                // Reset body length counter for new file
                bodyLength = 0;
                
                // Move position after headers
                pos = headersEnd + 4; // +4 for \r\n\r\n
            }
        } else {
            // No more boundaries found - write remaining data except last potential boundary
            // Save the last bytes as leftover in case they're part of a boundary
            size_t reserveBytes = std::min(body.length() - pos, boundary.length() + 4); // boundary + CRLF + CRLF
            
            if (body.length() - reserveBytes > pos) {
                // Write all except reserved bytes
                file.write(body.data() + pos, body.length() - pos - reserveBytes);
                bodyLength += (body.length() - pos - reserveBytes);
            }
            
            // Save reserved bytes as leftover
            this->leftoverData = body.substr(body.length() - reserveBytes);
            break;
        }
    }
}


